//
//  BreathSlider.m
//  eHealthCare
//
//  Created by John shi on 2018/10/12.
//  Copyright © 2018年 Jon Shi. All rights reserved.
//

#import "BreathSlider.h"
#define ToRad(deg)         ( (M_PI * (deg)) / 180.0 )
#define ToDeg(rad)        ( (180.0 * (rad)) / M_PI )
#define SQR(x)            ( (x) * (x) )
@implementation BreathSlider{
    CGFloat radius;
}





-(id)initWithFrame:(CGRect)frame{
    if ([super initWithFrame:frame]) {
        _lineWidth = 5;
    }
    return self;
}

- (void)drawRect:(CGRect)rect {
    [super drawRect:rect];
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGPoint aPoints[2];//坐标点
    
    aPoints[0] =CGPointMake(_lineWidth,rect.size.height/2.0);//坐标1
    
    aPoints[1] =CGPointMake(rect.size.width-_lineWidth, rect.size.height/2.0);//坐标2
    //1.绘制灰色的背景
    CGContextAddLines(context, aPoints, 2);
    //    CGContextAddArc(context, self.frame.size.width/2, self.frame.size.height/2, radius, 0, M_PI*2, 0);
    [[UIColor grayColor] setStroke];
    CGContextSetLineWidth(context, _lineWidth);
    CGContextSetLineCap(context, kCGLineCapButt);
    CGContextDrawPath(context, kCGPathStroke);
    
    //2.绘制进度
    CGContextAddLines(context, aPoints, 2);
    //    CGContextAddArc(context, self.frame.size.width/2, self.frame.size.height/2,radius,0, ToRad(_angle), 0);
    [[UIColor redColor] setStroke];
    CGContextSetLineWidth(context, _lineWidth);
    CGContextSetLineCap(context, kCGLineCapRound);
    CGContextDrawPath(context, kCGPathStroke);
    
    //3.绘制拖动小块
    CGPoint handleCenter =  self.angle;//[self pointFromAngle: (self.angle)];
    CGContextSetShadowWithColor(context, CGSizeMake(0, 0), 3,[UIColor blueColor].CGColor);
    [[UIColor redColor] setStroke];
    CGContextSetLineWidth(context, _lineWidth*2);
    CGContextAddEllipseInRect(context, CGRectMake(handleCenter.x, handleCenter.y, _lineWidth*2, _lineWidth*2));
    CGContextDrawPath(context, kCGPathStroke);
}

-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{
    [super beginTrackingWithTouch:touch withEvent:event];
    return YES;
}


-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{
    [super continueTrackingWithTouch:touch withEvent:event];
    //获取触摸点
    CGPoint lastPoint = [touch locationInView:self];
    //使用触摸点来移动小块
    if (lastPoint.x>=_lineWidth&&lastPoint.x<=self.frame.size.width-(2*_lineWidth)) {
        [self movehandle:lastPoint];
        //发送值改变事件
        [self sendActionsForControlEvents:UIControlEventValueChanged];
    }
    
    return YES;
}

-(void)movehandle:(CGPoint)lastPoint{
    
    //获得中心点
    CGPoint centerPoint = CGPointMake(lastPoint.x,
                                      self.frame.size.height/2.0-_lineWidth);
    
    
    //保存新角度
    self.angle = centerPoint;
    
    //重新绘制
    [self setNeedsDisplay];
}

-(void)changeAngle:(CGPoint)angle{
    _angle = angle;
    [self sendActionsForControlEvents:UIControlEventValueChanged];
    [self setNeedsDisplay];
}

@end
